[JNDI Gadget] <javax.management.remote.JMXServiceURL: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.remote.JMXServiceURL: void validate(java.lang.String,java.lang.String,int,java.lang.String)>
 -> <javax.management.remote.JMXServiceURL: void validateHost(java.lang.String,int)>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.rmi.server.UnicastRemoteObject: void readObject(java.io.ObjectInputStream)>
 -> <java.rmi.server.UnicastRemoteObject: void reexport()>
 -> <java.rmi.server.UnicastRemoteObject: java.rmi.Remote exportObject(java.rmi.Remote,int)>
 -> <java.rmi.server.UnicastRemoteObject: java.rmi.Remote exportObject(java.rmi.Remote,sun.rmi.server.UnicastServerRef)>
 -> <sun.rmi.server.UnicastServerRef: java.rmi.Remote exportObject(java.rmi.Remote,java.lang.Object,boolean)>
 -> <sun.rmi.transport.LiveRef: void exportObject(sun.rmi.transport.Target)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.net.SocketPermission: boolean equals(java.lang.Object)>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.net.SocketPermission: boolean equals(java.lang.Object)>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: boolean equals(java.lang.Object)>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <sun.rmi.server.UnicastRef2: void readExternal(java.io.ObjectInput)>
 -> <sun.rmi.transport.LiveRef: sun.rmi.transport.LiveRef read(java.io.ObjectInput,boolean)>
 -> <sun.rmi.transport.DGCClient: void registerRefs(sun.rmi.transport.Endpoint,java.util.List)>
 -> <sun.rmi.transport.DGCClient$EndpointEntry: boolean registerRefs(java.util.List)>
 -> <sun.rmi.transport.DGCClient$EndpointEntry: void makeDirtyCall(java.util.Set,long)>
 -> <sun.rmi.transport.DGCImpl_Stub: java.rmi.dgc.Lease dirty(java.rmi.server.ObjID[],long,java.rmi.dgc.Lease)>
 -> <sun.rmi.server.UnicastRef: java.rmi.server.RemoteCall newCall(java.rmi.server.RemoteObject,java.rmi.server.Operation[],int,long)>
 -> <sun.rmi.transport.LiveRef: sun.rmi.transport.Channel getChannel()>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <sun.rmi.server.UnicastRef: void readExternal(java.io.ObjectInput)>
 -> <sun.rmi.transport.LiveRef: sun.rmi.transport.LiveRef read(java.io.ObjectInput,boolean)>
 -> <sun.rmi.transport.DGCClient: void registerRefs(sun.rmi.transport.Endpoint,java.util.List)>
 -> <sun.rmi.transport.DGCClient$EndpointEntry: boolean registerRefs(java.util.List)>
 -> <sun.rmi.transport.DGCClient$EndpointEntry: void makeDirtyCall(java.util.Set,long)>
 -> <sun.rmi.transport.DGCImpl_Stub: java.rmi.dgc.Lease dirty(java.rmi.server.ObjID[],long,java.rmi.dgc.Lease)>
 -> <sun.rmi.server.UnicastRef: java.rmi.server.RemoteCall newCall(java.rmi.server.RemoteObject,java.rmi.server.Operation[],int,long)>
 -> <sun.rmi.transport.LiveRef: sun.rmi.transport.Channel getChannel()>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.AbstractType: int getHashCode(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.LinkedHashMap: void afterNodeInsertion(boolean)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.ComponentType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.net.URL: boolean equals(java.lang.Object)>
 -> <java.net.URLStreamHandler: boolean equals(java.net.URL,java.net.URL)>
 -> <java.net.URLStreamHandler: boolean sameFile(java.net.URL,java.net.URL)>
 -> <java.net.URLStreamHandler: boolean hostsEqual(java.net.URL,java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.CustomType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.EnumType: int hashCode(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.CustomType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.StringClobType: int hashCode(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.AbstractType: int getHashCode(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.LinkedHashMap: void afterNodeInsertion(boolean)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.net.URL: boolean equals(java.lang.Object)>
 -> <java.net.URLStreamHandler: boolean equals(java.net.URL,java.net.URL)>
 -> <java.net.URLStreamHandler: boolean sameFile(java.net.URL,java.net.URL)>
 -> <java.net.URLStreamHandler: boolean hostsEqual(java.net.URL,java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.spi.TypedValue: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.AbstractLobType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.ByteArrayBlobType: int getHashCode(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.internal.util.collections.ArrayHelper: int hash(java.lang.Object[])>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.AbstractStandardBasicType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.descriptor.java.AbstractTypeDescriptor: int extractHashCode(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.net.URL: boolean equals(java.lang.Object)>
 -> <java.net.URLStreamHandler: boolean equals(java.net.URL,java.net.URL)>
 -> <java.net.URLStreamHandler: boolean sameFile(java.net.URL,java.net.URL)>
 -> <java.net.URLStreamHandler: boolean hostsEqual(java.net.URL,java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.TypedValue: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.engine.spi.TypedValue: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.CustomType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.EnumType: int hashCode(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.CustomType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.StringClobType: int hashCode(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.AbstractStandardBasicType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.descriptor.java.AbstractTypeDescriptor: int extractHashCode(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.cache.spi.QueryKey: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.QueryKey: int generateHashCode()>
 -> <org.hibernate.type.AbstractLobType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.ByteArrayBlobType: int getHashCode(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.internal.util.collections.ArrayHelper: int hash(java.lang.Object[])>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.AbstractStandardBasicType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.descriptor.java.AbstractTypeDescriptor: java.lang.String extractLoggableRepresentation(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.Format: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.Format: java.lang.String format(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.AbstractType: int getHashCode(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.AbstractStandardBasicType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.descriptor.java.AbstractTypeDescriptor: java.lang.String extractLoggableRepresentation(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.Format: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.Format: java.lang.String format(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CollectionType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomCollectionType: java.lang.String renderLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.CustomType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.EnumType: int hashCode(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.CustomType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.StringClobType: int hashCode(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.Format: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.Format: java.lang.String format(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.AbstractStandardBasicType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.descriptor.java.AbstractTypeDescriptor: java.lang.String extractLoggableRepresentation(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toXMLString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toString(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.spi.TypedValue: int hashCode()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.ComponentType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.Format: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.Format: java.lang.String format(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CollectionType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomCollectionType: java.lang.String renderLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.AbstractStandardBasicType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.descriptor.java.AbstractTypeDescriptor: java.lang.String extractLoggableRepresentation(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.AbstractInMemoryContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer: com.vaadin.data.Item getUnfilteredItem(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.ComponentType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toXMLString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toString(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <org.hibernate.engine.spi.TypedValue: int hashCode()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.ComponentType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CollectionType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomCollectionType: java.lang.String renderLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.TypedValue: int hashCode()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.ComponentType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.function.BinaryOperator$lambda_minBy_0__112: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.function.BinaryOperator: java.lang.Object lambda$minBy$0(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.function.BinaryOperator$lambda_minBy_0__112: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.function.BinaryOperator: java.lang.Object lambda$minBy$0(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getHeight(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.function.BinaryOperator$lambda_minBy_0__112: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.function.BinaryOperator: java.lang.Object lambda$minBy$0(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.AbstractLobType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.ByteArrayBlobType: int getHashCode(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.internal.util.collections.ArrayHelper: int hash(java.lang.Object[])>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.CacheKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CollectionType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomCollectionType: java.lang.String renderLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.AbstractType: int getHashCode(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getHeight(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.function.BinaryOperator$lambda_minBy_0__112: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.function.BinaryOperator: java.lang.Object lambda$minBy$0(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toXMLString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toString(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toXMLString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toString(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.function.BinaryOperator$lambda_maxBy_1__113: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.function.BinaryOperator: java.lang.Object lambda$maxBy$1(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.function.BinaryOperator$lambda_maxBy_1__113: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.function.BinaryOperator: java.lang.Object lambda$maxBy$1(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.QueryKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityUniqueKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.CustomType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.StringClobType: int hashCode(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.GeneratedPropertyContainer$GeneratedPropertyItem: com.vaadin.data.Property getItemProperty(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doPut(java.lang.Object,java.lang.Object,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doPut(java.lang.Object,java.lang.Object,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doPut(java.lang.Object,java.lang.Object,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.Format: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.Format: java.lang.String format(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.AbstractInMemoryContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer: com.vaadin.data.Item getUnfilteredItem(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.AbstractStandardBasicType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.descriptor.java.AbstractTypeDescriptor: java.lang.String extractLoggableRepresentation(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.CustomType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.EnumType: int hashCode(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doPut(java.lang.Object,java.lang.Object,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.Collectors$lambda_toCollection_2__153: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: java.util.Collection lambda$toCollection$2(java.util.Collection,java.util.Collection)>
 -> <java.util.concurrent.ConcurrentHashMap$KeySetView: boolean addAll(java.util.Collection)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.EntityKey: boolean sameIdentifier(org.hibernate.engine.spi.EntityKey)>
 -> <org.hibernate.type.EntityType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet convertAttributeSet(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: boolean isDefined(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.internal.NaturalIdXrefDelegate$CachedNaturalId: boolean isSame(java.lang.Object[])>
 -> <org.hibernate.type.ComponentType: boolean isEqual(java.lang.Object,java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <sun.misc.Cache: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.AbstractType: int getHashCode(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CollectionType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomCollectionType: java.lang.String renderLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.IntPipeline$lambda_collect_5__284: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.IntPipeline: java.lang.Object lambda$collect$5(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_49__214: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$49(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.DoublePipeline$lambda_collect_8__259: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.DoublePipeline: java.lang.Object lambda$collect$8(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_49__214: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$49(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.AbstractType: int getHashCode(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.AbstractInMemoryContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer: com.vaadin.data.Item getUnfilteredItem(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.LongPipeline$lambda_collect_5__300: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.LongPipeline: java.lang.Object lambda$collect$5(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_49__214: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$49(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getHeight(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.IntPipeline$lambda_collect_5__284: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.IntPipeline: java.lang.Object lambda$collect$5(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_51__212: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$51(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.cache.spi.NaturalIdCacheKey: java.lang.String toString()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.AbstractLobType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.ByteArrayBlobType: int getHashCode(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.internal.util.collections.ArrayHelper: int hash(java.lang.Object[])>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.Collectors$lambda_toCollection_2__153: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: java.util.Collection lambda$toCollection$2(java.util.Collection,java.util.Collection)>
 -> <java.util.concurrent.ConcurrentHashMap$EntrySetView: boolean addAll(java.util.Collection)>
 -> <java.util.concurrent.ConcurrentHashMap$EntrySetView: boolean add(java.util.Map$Entry)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.DoublePipeline$lambda_collect_8__259: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.DoublePipeline: java.lang.Object lambda$collect$8(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_toConcurrentMap_59__224: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$toConcurrentMap$59(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getHeight(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.Collectors$lambda_toCollection_2__153: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: java.util.Collection lambda$toCollection$2(java.util.Collection,java.util.Collection)>
 -> <java.util.concurrent.ConcurrentHashMap$EntrySetView: boolean addAll(java.util.Collection)>
 -> <java.util.concurrent.ConcurrentHashMap$EntrySetView: boolean add(java.util.Map$Entry)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageUpdatableContext: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getHeight(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.IntPipeline$lambda_collect_5__284: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.IntPipeline: java.lang.Object lambda$collect$5(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_49__214: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$49(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.LongPipeline$lambda_collect_5__300: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.LongPipeline: java.lang.Object lambda$collect$5(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_toConcurrentMap_59__224: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$toConcurrentMap$59(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getHeight(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.DoublePipeline$lambda_collect_8__259: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.DoublePipeline: java.lang.Object lambda$collect$8(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_51__212: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$51(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.LinkedHashMap: void afterNodeInsertion(boolean)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <org.hibernate.engine.spi.TypedValue: int hashCode()>
 -> <org.hibernate.internal.util.ValueHolder: java.lang.Object getValue()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Object initialize()>
 -> <org.hibernate.engine.spi.TypedValue$1: java.lang.Integer initialize()>
 -> <org.hibernate.type.ComponentType: int getHashCode(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getHeight(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.LongPipeline$lambda_collect_5__300: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.LongPipeline: java.lang.Object lambda$collect$5(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_51__212: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$51(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.EnumType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.AbstractInMemoryContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer: com.vaadin.data.Item getUnfilteredItem(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.Permissions: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toXMLString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.type.CustomType: java.lang.String toString(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.persister.entity.DiscriminatorType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.LongPipeline$lambda_collect_5__300: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.LongPipeline: java.lang.Object lambda$collect$5(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_51__212: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$51(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.BasicPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: boolean containsKey(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.AbstractProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.security.PermissionsHash: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.DoublePipeline$lambda_collect_8__259: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.DoublePipeline: java.lang.Object lambda$collect$8(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentMap$lambda_replaceAll_0__593: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentMap: void lambda$replaceAll$0(java.util.function.BiFunction,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.DoublePipeline$lambda_collect_8__259: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.DoublePipeline: java.lang.Object lambda$collect$8(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_51__212: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$51(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialArray: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getHeight(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.LongPipeline$lambda_collect_5__300: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.LongPipeline: java.lang.Object lambda$collect$5(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_49__214: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$49(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <javax.swing.UIDefaults: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.handler.MessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: boolean containsKey(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.html.StyleSheet: javax.swing.text.AttributeSet removeHTMLTags(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isDefined(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PropertyPermissionCollection: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: void putAll(java.util.Map)>
 -> <java.util.HashMap: void putMapEntries(java.util.Map,boolean)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: void addAttributes(javax.swing.text.AttributeSet)>
 -> <sun.misc.Cache: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode find(int,java.lang.Object,java.lang.Class)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <sun.swing.BakedArrayList: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.RowId: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: boolean setCurrentSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.collection.internal.AbstractPersistentCollection: java.lang.String generateUnexpectedSessionStateMessage(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,org.hibernate.collection.spi.PersistentCollection,java.io.Serializable,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.type.CompositeCustomType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object putVal(java.lang.Object,java.lang.Object,boolean)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean equals(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap$SimpleEntry: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <java.util.HashMap$TreeNode: java.util.HashMap$TreeNode putTreeVal(java.util.HashMap,java.util.HashMap$Node[],int,java.lang.Object,java.lang.Object)>
 -> <java.util.HashMap: int compareComparables(java.lang.Class,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.LongPipeline$lambda_collect_5__300: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.LongPipeline: java.lang.Object lambda$collect$5(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentMap$lambda_replaceAll_0__593: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentMap: void lambda$replaceAll$0(java.util.function.BiFunction,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument$AbstractElement: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.html.HTML$UnknownTag: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <org.hibernate.internal.SessionImpl: void readObject(java.io.ObjectInputStream)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: org.hibernate.engine.internal.StatefulPersistenceContext deserialize(java.io.ObjectInputStream,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setSession(org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.proxy.AbstractLazyInitializer: void setReadOnly(boolean)>
 -> <org.hibernate.engine.internal.StatefulPersistenceContext: boolean containsEntity(org.hibernate.engine.spi.EntityKey)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$LeafElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: void addEntry(int,java.lang.Object,java.lang.Object,int)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.JCheckBox: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JCheckBox: void updateUI()>
 -> <javax.swing.AbstractButton: void setUI(javax.swing.plaf.ButtonUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.util.TreeMap: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.JLayer: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.JLayer: void setUI(javax.swing.plaf.LayerUI)>
 -> <javax.swing.JComponent: void setUI(javax.swing.plaf.ComponentUI)>
 -> <javax.swing.JComponent: void uninstallUIAndProperties()>
 -> <javax.swing.JComponent: void putClientProperty(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <javax.swing.text.InternationalFormatter: java.lang.Object stringToValue(java.lang.String)>
 -> <javax.swing.text.InternationalFormatter: boolean isValidValue(java.lang.Object,boolean)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.HashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.HashMap: java.lang.Object putVal(int,java.lang.Object,java.lang.Object,boolean,boolean)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <javax.swing.text.InternationalFormatter: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.InternationalFormatter: void updateMaskIfNecessary()>
 -> <javax.swing.text.InternationalFormatter: void updateMask()>
 -> <java.text.MessageFormat: java.text.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)>
 -> <java.text.MessageFormat: java.lang.StringBuffer subformat(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition,java.util.List)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.AbstractDocument: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.AbstractDocument$BidiElement: void <init>(javax.swing.text.AbstractDocument,javax.swing.text.Element,int,int,int)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.AbstractDocument$AbstractElement: void removeAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet removeAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.ImageIcon: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.ImageIcon: void loadImage(java.awt.Image)>
 -> <sun.awt.image.AbstractMultiResolutionImage: int getWidth(java.awt.image.ImageObserver)>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getBaseImage()>
 -> <sun.awt.image.MultiResolutionCachedImage: java.awt.Image getResolutionVariant(int,int)>
 -> <java.util.stream.IntPipeline$lambda_collect_5__284: java.lang.Object apply(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.IntPipeline: java.lang.Object lambda$collect$5(java.util.function.BiConsumer,java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors$lambda_groupingByConcurrent_51__212: void accept(java.lang.Object,java.lang.Object)>
 -> <java.util.stream.Collectors: void lambda$groupingByConcurrent$51(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object computeIfAbsent(java.lang.Object,java.util.function.Function)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.swing.text.StyleContext$NamedStyle: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.StyleContext: void readAttributeSet(java.io.ObjectInputStream,javax.swing.text.MutableAttributeSet)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttribute(java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttribute(javax.swing.text.AttributeSet,java.lang.Object,java.lang.Object)>
 -> <javax.swing.text.StyleContext$NamedStyle: void addAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet addAttributes(javax.swing.text.AttributeSet,javax.swing.text.AttributeSet)>
 -> <javax.swing.text.StyleContext: javax.swing.text.AttributeSet getImmutableUniqueSet()>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.Object,java.lang.Object)>
 -> <com.sun.xml.internal.ws.server.EndpointMessageContextImpl: java.lang.Object put(java.lang.String,java.lang.Object)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <org.hibernate.engine.spi.CollectionKey: java.lang.String toString()>
 -> <org.hibernate.pretty.MessageHelper: java.lang.String collectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.pretty.MessageHelper: void addIdToCollectionInfoString(org.hibernate.persister.collection.CollectionPersister,java.io.Serializable,org.hibernate.engine.spi.SessionFactoryImplementor,java.lang.StringBuilder)>
 -> <org.hibernate.type.EntityType: java.lang.String toLoggableString(java.lang.Object,org.hibernate.engine.spi.SessionFactoryImplementor)>
 -> <org.hibernate.persister.entity.AbstractEntityPersister: java.io.Serializable getIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.swing.text.SimpleAttributeSet: boolean equals(java.lang.Object)>
 -> <javax.swing.text.SimpleAttributeSet: boolean isEqual(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.SimpleAttributeSet: boolean containsAttributes(javax.swing.text.AttributeSet)>
 -> <javax.swing.text.rtf.MockAttributeSet: java.lang.Object getAttribute(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.Hashtable: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: void reconstitutionPut(java.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <java.util.concurrent.ConcurrentHashMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Class getType()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.GeneratedPropertyContainer$GeneratedPropertyItem: com.vaadin.data.Property getItemProperty(java.lang.Object)>
 -> <java.util.HashMap: boolean containsKey(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.SimpleStringFilter: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.CopyOnWriteArrayList: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Class getType()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.PropertysetItem: java.lang.String toString()>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.ui.AbstractField: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.FreeformQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.sqlcontainer.TemporaryRowId: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Between: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <sun.util.PreHashedMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void updateOffsetAndCache(int)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.EnumMap: boolean equals(java.lang.Object)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.IsNull: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XStringForFSB: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.sql.rowset.serial.SerialStruct: boolean equals(java.lang.Object)>
 -> <java.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])>
 -> <com.sun.org.apache.xpath.internal.objects.XString: boolean equals(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.String toString()>
 -> <com.vaadin.data.util.LegacyPropertyHelper: java.lang.String legacyPropertyToString(com.vaadin.data.Property)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.concurrent.ConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Compare: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.BoundedConcurrentHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.TreeMap: boolean containsKey(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.AbstractInMemoryContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer: com.vaadin.data.Item getUnfilteredItem(java.lang.Object)>
 -> <java.util.Hashtable: boolean containsKey(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.MethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: java.lang.Object get(java.lang.Object)>
 -> <org.hibernate.internal.util.collections.ConcurrentReferenceHashMap: int hashOf(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.HashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.LinkedHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.HashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean itemPassesFilters(com.vaadin.data.util.sqlcontainer.RowItem)>
 -> <com.vaadin.data.util.filter.Like: boolean passesFilter(java.lang.Object,com.vaadin.data.Item)>
 -> <com.vaadin.data.util.NestedMethodProperty: java.lang.Object getValue()>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <javax.management.BadAttributeValueExpException: void readObject(java.io.ObjectInputStream)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.TreeMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntry(java.lang.Object)>
 -> <java.util.TreeMap: java.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter$DefaultPropertyValueComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <java.util.WeakHashMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.WeakHashMap: int hash(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.ImmutableDescriptor: boolean equals(java.lang.Object)>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object[] getFieldValues(java.lang.String[])>
 -> <javax.management.modelmbean.DescriptorSupport: java.lang.Object getFieldValue(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.ComponentType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.ComponentType: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.tuple.component.AbstractComponentTuplizer: java.lang.Object getPropertyValue(java.lang.Object,int)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults: java.lang.Object get(java.lang.Object)>
 -> <javax.swing.UIDefaults: java.lang.Object getFromHashtable(java.lang.Object)>
 -> <java.util.Hashtable: java.lang.Object remove(java.lang.Object)>
 -> <java.net.URL: int hashCode()>
 -> <java.net.URLStreamHandler: int hashCode(java.net.URL)>
 -> <java.net.URLStreamHandler: java.net.InetAddress getHostAddress(java.net.URL)>
 -> <java.net.URL: java.net.InetAddress getHostAddress()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: com.vaadin.data.Item getItem(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: int indexOfId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: void getPage()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.ResultSetMetaData getMetaData()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.PreparedStatement prepare()>
 -> <com.sun.rowset.JdbcRowSetImpl: java.sql.Connection connect()>
 -> <javax.naming.Context: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.naming.RefAddr: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.CollectionAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

[JNDI Gadget] <java.util.PriorityQueue: void readObject(java.io.ObjectInputStream)>
 -> <java.util.PriorityQueue: void heapify()>
 -> <java.util.PriorityQueue: void siftDown(int,java.lang.Object)>
 -> <java.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <java.util.Comparators$NaturalOrderComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <javax.management.ObjectName: int compareTo(java.lang.Object)>
 -> <javax.management.ObjectName: int compareTo(javax.management.ObjectName)>
 -> <javax.management.ObjectName: java.lang.String getKeyProperty(java.lang.String)>
 -> <javax.swing.UIDefaults$TextAndMnemonicHashMap: java.lang.Object get(java.lang.Object)>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerItem: java.lang.String toString()>
 -> <com.vaadin.data.util.IndexedContainer$IndexedContainerProperty: java.lang.Object getValue()>
 -> <java.util.Hashtable: java.lang.Object get(java.lang.Object)>
 -> <java.net.SocketPermission: int hashCode()>
 -> <java.net.SocketPermission: void getCanonName()>
 -> <java.net.InetAddress: java.net.InetAddress getByName(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[JNDI Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <javax.management.openmbean.CompositeDataSupport: boolean equals(java.lang.Object)>
 -> <javax.management.openmbean.CompositeDataSupport: java.lang.Object get(java.lang.String)>
 -> <java.util.concurrent.ConcurrentSkipListMap: boolean containsKey(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compare(java.lang.Object,java.lang.Object)>
 -> <com.vaadin.data.util.DefaultItemSorter: int compareProperty(java.lang.Object,boolean,com.vaadin.data.Item,com.vaadin.data.Item)>
 -> <com.vaadin.ui.AbstractSelect: java.lang.Object getValue()>
 -> <com.vaadin.data.util.sqlcontainer.SQLContainer: boolean containsId(java.lang.Object)>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: boolean containsRowWithKey(java.lang.Object[])>
 -> <com.vaadin.data.util.sqlcontainer.query.TableQuery: java.sql.ResultSet executeQuery(com.vaadin.data.util.sqlcontainer.query.generator.StatementHelper)>
 -> <com.vaadin.data.util.sqlcontainer.query.AbstractTransactionalQuery: java.sql.Connection getConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: java.sql.Connection reserveConnection()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource getDataSource()>
 -> <com.vaadin.data.util.sqlcontainer.connection.J2EEConnectionPool: javax.sql.DataSource lookupDataSource()>
 -> <javax.naming.InitialContext: java.lang.Object lookup(java.lang.String)>

[INVOKE Gadget] <java.util.concurrent.ConcurrentHashMap: void readObject(java.io.ObjectInputStream)>
 -> <java.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)>
 -> <java.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)>
 -> <java.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)>
 -> <java.util.Hashtable: boolean equals(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object get(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: java.lang.Object doGet(java.lang.Object)>
 -> <java.util.concurrent.ConcurrentSkipListMap: int cpr(java.util.Comparator,java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.internal.util.compare.ComparableComparator: int compare(java.lang.Comparable,java.lang.Comparable)>
 -> <org.hibernate.action.internal.EntityAction: int compareTo(java.lang.Object)>
 -> <org.hibernate.type.AnyType: int compare(java.lang.Object,java.lang.Object)>
 -> <org.hibernate.type.AnyType: java.lang.Object extractIdentifier(java.lang.Object)>
 -> <org.hibernate.tuple.entity.AbstractEntityTuplizer: java.io.Serializable getIdentifier(java.lang.Object,org.hibernate.engine.spi.SessionImplementor)>
 -> <org.hibernate.property.BasicPropertyAccessor$BasicGetter: java.lang.Object get(java.lang.Object)>
 -> <java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])>

